"""KIS OpenAPI REST Client"""

import logging
import time
from datetime import datetime, timedelta
from decimal import Decimal
from typing import Optional

import httpx

from ..port.broker_port import (
    APIError,
    AuthenticationError,
    AuthenticationToken,
    BrokerError,
    ConnectionError,
    FillEvent,
    Order,
    OrderRequest,
    OrderSide,
    OrderType,
    RateLimitError,
)
from .kis_config import KISConfig

logger = logging.getLogger(__name__)


class TokenManager:
    """인증 토큰 관리자"""

    def __init__(self, config: KISConfig, client: httpx.Client):
        self.config = config
        self.client = client
        self._token: Optional[AuthenticationToken] = None
        self._token_lock = False

    def get_token(self) -> AuthenticationToken:
        """현재 유효한 토큰 반환

        토큰이 만료 5분 전이면 자동 갱신합니다.
        """
        if self._needs_refresh():
            self._refresh_token()
        return self._token

    def _needs_refresh(self) -> bool:
        """토큰 갱신 필요 여부 확인 (만료 5분 전)"""
        if self._token is None:
            return True
        five_minutes_from_now = datetime.now() + timedelta(minutes=5)
        return self._token.expires_at < five_minutes_from_now

    def _refresh_token(self) -> None:
        """토큰 갱신"""
        if self._token_lock:
            # 이미 갱신 중인 경우 대기
            time.sleep(0.1)
            return

        self._token_lock = True
        try:
            response = self.client.post(
                self.config.get_token_url(),
                json={
                    "grant_type": "client_credentials",
                    "appkey": self.config.kis_app_key,
                    "appsecret": self.config.kis_app_secret,
                },
                headers={"Content-Type": "application/json"},
            )

            if response.status_code == 200:
                data = response.json()
                self._token = AuthenticationToken(
                    access_token=data["access_token"],
                    token_type=data["token_type"],
                    expires_in=int(data["expires_in"]),
                    expires_at=datetime.now() + timedelta(seconds=int(data["expires_in"])),
                )
                logger.info("Token refreshed successfully")
            else:
                raise AuthenticationError(
                    f"Token refresh failed: {response.status_code} - {response.text}"
                )
        finally:
            self._token_lock = False

    def force_refresh(self) -> None:
        """토큰 강제 갱신"""
        self._token = None
        self._refresh_token()


class KISRestClient:
    """한국투자증권 OpenAPI REST 클라이언트"""

    def __init__(self, config: KISConfig):
        self.config = config
        self.client = httpx.Client(
            base_url=self.config.get_rest_base_url(),
            timeout=self.config.request_timeout,
        )
        self.token_manager = TokenManager(config, self.client)

    def _get_headers(self, include_token: bool = True) -> dict:
        """요청 헤더 생성"""
        headers = {
            "Content-Type": "application/json; charset=utf-8",
            "appkey": self.config.kis_app_key,
            "appsecret": self.config.kis_app_secret,
        }

        if include_token:
            token = self.token_manager.get_token()
            headers["authorization"] = f"Bearer {token.access_token}"

        return headers

    def _make_request(
        self,
        method: str,
        url: str,
        params: Optional[dict] = None,
        json_data: Optional[dict] = None,
        max_retries: int = 3,
    ) -> dict:
        """API 요청 (재시도 로직 포함)"""
        retry_count = 0
        base_delay = 1

        while retry_count < max_retries:
            try:
                response = self.client.request(
                    method,
                    url,
                    headers=self._get_headers(),
                    params=params,
                    json=json_data,
                )

                # 토큰 만료 시 자동 갱신 후 재시도
                if response.status_code == 401 and retry_count == 0:
                    logger.warning("Received 401, refreshing token and retrying...")
                    self.token_manager.force_refresh()
                    retry_count += 1
                    continue

                # Rate Limit 처리
                if response.status_code == 429:
                    if retry_count < max_retries - 1:
                        delay = base_delay * (2**retry_count)
                        logger.warning(f"Rate limit exceeded, retrying in {delay}s...")
                        time.sleep(delay)
                        retry_count += 1
                        continue
                    raise RateLimitError("Rate limit exceeded")

                if response.status_code >= 400:
                    error_msg = f"API request failed: {response.status_code} - {response.text}"
                    logger.error(error_msg)
                    raise APIError(error_msg)

                return response.json()

            except httpx.TimeoutException as e:
                if retry_count < max_retries - 1:
                    delay = base_delay * (2**retry_count)
                    logger.warning(f"Timeout, retrying in {delay}s...")
                    time.sleep(delay)
                    retry_count += 1
                    continue
                raise ConnectionError(f"Request timeout: {e}")
            except httpx.NetworkError as e:
                if retry_count < max_retries - 1:
                    delay = base_delay * (2**retry_count)
                    logger.warning(f"Network error, retrying in {delay}s...")
                    time.sleep(delay)
                    retry_count += 1
                    continue
                raise ConnectionError(f"Network error: {e}")

        raise APIError(f"Max retries exceeded for request to {url}")

    def get_access_token(self) -> AuthenticationToken:
        """접근 토큰 발급"""
        return self.token_manager.get_token()

    def get_hashkey(self, request_body: dict) -> str:
        """해시키 발급

        Args:
            request_body: 요청 본문

        Returns:
            str: 해시키
        """
        try:
            response = self._make_request(
                "POST",
                self.config.get_hashkey_url(),
                json_data=request_body,
                include_token=False,
            )
            return response["HASH"]
        except Exception as e:
            logger.warning(f"Hashkey generation failed, continuing without hashkey: {e}")
            return ""

    # TAG-001: SPEC-BACKEND-API-001 NEW-001 WebSocket approval_key 발급
    def get_approval_key(self) -> str:
        """WebSocket approval_key 발급

        KIS OpenAPI /oauth2/Approval 엔드포인트를 호출하여
        WebSocket 연결에 필요한 approval_key를 발급받습니다.

        Returns:
            str: approval_key

        Raises:
            AuthenticationError: 발급 실패 시
        """
        try:
            response = self._make_request(
                "POST",
                self.config.get_approval_url(),
                include_token=False,  # 토큰 없이 appkey/appsecret만 사용
            )
            approval_key = response.get("approval_key")
            if not approval_key:
                raise AuthenticationError("approval_key not found in response")
            logger.info("Approval key generated successfully")
            return approval_key
        except Exception as e:
            logger.error(f"Approval key generation failed: {e}")
            raise AuthenticationError(f"Approval key generation failed: {e}")

    def place_order(self, order: OrderRequest) -> str:
        """주문 전송

        Args:
            order: 주문 요청

        Returns:
            str: 브로커 주문 ID

        Raises:
            APIError: 주문 실패 시
        """
        # 주문 본문 구성
        body = {
            "CANO": order.account_id[:8],  # 계좌번호 (앞 8자)
            "ACNT_PRDT_CD": order.account_id[8:],  # 계좌상품코드 (뒤 2자)
            "PDNO": order.symbol,  # 종목코드
            "ORD_DVSN": "01"
            if order.side == OrderSide.BUY
            else "02",  # 주문구분 (01: 매수, 02: 매도)
            "ORD_QTY": str(order.qty),  # 주문수량
            "ORD_UNPR": str(order.price) if order.price else "",  # 주문가격 (지정가만)
            "ORD_DVSN": "01"
            if order.order_type == OrderType.MARKET
            else "00",  # 주문구분 (00: 지정가, 01: 시장가)
        }

        # 해시키 생성
        hashkey = self.get_hashkey(body)
        headers = self._get_headers()
        if hashkey:
            headers["hashkey"] = hashkey

        # 주문 전송
        response = self._make_request(
            "POST",
            "/uapi/domestic-stock/v1/trading/order-cash",
            json_data=body,
        )

        # 주문 ID 반환
        return response["output"]["ODNO"]

    def cancel_order(self, broker_order_id: str, account_id: str) -> bool:
        """주문 취소

        Args:
            broker_order_id: 취소할 주문 ID
            account_id: 계좌 ID

        Returns:
            bool: 취소 성공 여부
        """
        body = {
            "CANO": account_id[:8],
            "ACNT_PRDT_CD": account_id[8:],
            "ODNO": broker_order_id,
            "ORD_DVSN": "02",  # 취소 주문
        }

        try:
            response = self._make_request(
                "POST",
                "/uapi/domestic-stock/v1/trading/order-rvsecncl",
                json_data=body,
            )
            return response["rt_cd"] == "0"
        except Exception as e:
            logger.error(f"Cancel order failed: {e}")
            return False

    def get_orders(self, account_id: str) -> list[Order]:
        """주문 목록 조회

        Args:
            account_id: 계좌 ID

        Returns:
            list[Order]: 주문 목록
        """
        params = {
            "CANO": account_id[:8],
            "ACNT_PRDT_CD": account_id[8:],
            "CTX_AREA_FK100": "",
            "CTX_AREA_NK100": "",
        }

        response = self._make_request(
            "GET",
            "/uapi/domestic-stock/v1/trading/inquire-psbl-rvsecncl",
            params=params,
        )

        orders = []
        for item in response.get("output", []):
            order = Order(
                broker_order_id=item["ODNO"],
                account_id=account_id,
                symbol=item["PDNO"],
                side=OrderSide.BUY if item["SLL_BK_DVSN"] == "BUY" else OrderSide.SELL,
                order_type=OrderType.MARKET if item["ORD_DVSN"] == "01" else OrderType.LIMIT,
                qty=Decimal(item["ORD_QTY"]),
                price=Decimal(item["ORD_UNPR"]) if item["ORD_UNPR"] else None,
                status=item["ORD_TPS"],
                created_at=datetime.now(),
            )
            orders.append(order)

        return orders

    def get_cash(self, account_id: str) -> Decimal:
        """예수금 조회

        투자계좌자산현황조회 API를 사용하여 예수금을 조회합니다.
        INQR_DVSN: 02 (예수금 전용)

        Args:
            account_id: 계좌 ID

        Returns:
            Decimal: 예수금

        Raises:
            APIError: 조회 실패 시
        """
        params = {
            "CANO": account_id[:8],
            "ACNT_PRDT_CD": account_id[8:],
            "INQR_DVSN": "02",  # 02: 예수금
        }

        response = self._make_request(
            "GET",
            "/uapi/domestic-stock/v1/trading/inquire-account-balance",
            params=params,
        )

        return Decimal(response["output"][0]["dnca_tot_amt"])

    def get_stock_balance(self, account_id: str) -> list[dict]:
        """주식잔고 조회

        주식잔고조회 API를 사용하여 계좌의 보유 종목 잔고를 조회합니다.

        Args:
            account_id: 계좌 ID

        Returns:
            list[dict]: 종목별 잔고 정보
                [
                    {
                        "pdno": "005930",           # 종목코드
                        "prdt_name": "삼성전자",      # 종목명
                        "hldg_qty": "1657",          # 보유수량
                        "pchs_avg_pric": "135440.25", # 매입평균가격
                        "pchs_amt": "224424497",     # 매입금액
                        "prpr": "0",                # 현재가
                        "evlu_amt": "0",             # 평가금액
                        "evlu_pfls_amt": "0",       # 평가손익금액
                        "evlu_pfls_rt": "0.00",     # 평가손익율
                    },
                    ...
                ]

        Raises:
            APIError: 조회 실패 시
        """
        params = {
            "CANO": account_id[:8],
            "ACNT_PRDT_CD": account_id[8:],
            "AFHR_FLPR_YN": "N",
            "INQR_DVSN": "01",
        }

        response = self._make_request(
            "GET",
            "/uapi/domestic-stock/v1/trading/inquire-balance",
            params=params,
        )

        return response.get("output1", [])

    def close(self) -> None:
        """클라이언트 종료"""
        self.client.close()
